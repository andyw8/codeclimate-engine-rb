# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/virtus/all/virtus.rbi
#
# virtus-1.0.5
module Virtus
  def self.coerce; end
  def self.coerce=(value); end
  def self.coercer(&block); end
  def self.config(&block); end
  def self.configuration; end
  def self.extended(object); end
  def self.finalize; end
  def self.included(object); end
  def self.model(options = nil, &block); end
  def self.module(options = nil, &block); end
  def self.value_object(options = nil, &block); end
  def self.warn(msg); end
end
class Virtus::Equalizer < Module
  def <<(key); end
  def define_cmp_method; end
  def define_hash_method; end
  def define_inspect_method; end
  def define_methods; end
  def include_comparison_methods; end
  def initialize(name, keys = nil); end
end
module Virtus::Equalizer::Methods
  def ==(other); end
  def eql?(other); end
end
module Virtus::Options
  def accept_options(*new_options); end
  def accepted_options; end
  def add_accepted_options(new_options); end
  def define_option_method(option); end
  def inherited(descendant); end
  def options; end
  def set_options(new_options); end
end
module Virtus::TypeLookup
  def determine_type(class_or_name); end
  def determine_type_and_cache(class_or_name); end
  def determine_type_from_descendant(descendant); end
  def determine_type_from_primitive(primitive); end
  def determine_type_from_string(string); end
  def primitive; end
  def self.extended(model); end
end
module Virtus::Model
  def self.extended(descendant); end
  def self.included(descendant); end
end
module Virtus::Model::Core
  def self.extended(descendant); end
  def self.included(descendant); end
end
module Virtus::Model::Constructor
  def self.included(descendant); end
end
module Virtus::Model::MassAssignment
  def self.extended(descendant); end
  def self.included(descendant); end
end
module Virtus::Extensions
  def self.extended(object); end
end
module Virtus::Extensions::Methods
  def attribute(name, type = nil, options = nil); end
  def attribute_set; end
  def self.extended(descendant); end
  def values(&block); end
end
module Virtus::Extensions::AllowedWriterMethods
  def allowed_writer_methods; end
end
module Virtus::ConstMissingExtensions
  def const_missing(name); end
end
module Virtus::ClassInclusions
  def self.included(descendant); end
end
module Virtus::ClassInclusions::Methods
  def allowed_writer_methods; end
  def attribute_set; end
end
module Virtus::ModuleExtensions
  def attribute(name, type = nil, options = nil); end
  def define_attributes(object); end
  def extended(object); end
  def included(object); end
  def self.extended(mod); end
  def self.setup(mod, inclusions = nil, attribute_definitions = nil); end
  include Virtus::ConstMissingExtensions
end
class Virtus::Configuration
  def coerce; end
  def coerce=(arg0); end
  def coercer(&block); end
  def constructor; end
  def constructor=(arg0); end
  def finalize; end
  def finalize=(arg0); end
  def initialize(options = nil); end
  def mass_assignment; end
  def mass_assignment=(arg0); end
  def nullify_blank; end
  def nullify_blank=(arg0); end
  def required; end
  def required=(arg0); end
  def strict; end
  def strict=(arg0); end
  def to_h; end
end
class Virtus::Builder
  def add_extended_hook; end
  def add_included_hook; end
  def config; end
  def extensions; end
  def initialize(conf, mod = nil); end
  def mod; end
  def options; end
  def self.call(options, &block); end
  def self.pending; end
  def with_hook_context; end
end
class Virtus::ModelBuilder < Virtus::Builder
end
class Virtus::ModuleBuilder < Virtus::Builder
  def add_included_hook; end
end
class Virtus::ValueObjectBuilder < Virtus::Builder
  def extensions; end
  def options; end
end
class Virtus::Builder::HookContext
  def attribute_method; end
  def builder; end
  def config; end
  def constructor?; end
  def finalize?; end
  def initialize(builder, config); end
  def initialize_attribute_method; end
  def mass_assignment?; end
  def modules; end
end
module Virtus::ClassMethods
  def allowed_methods; end
  def assert_valid_name(name); end
  def attribute_set; end
  def attributes; end
  def inherited(descendant); end
  def self.extended(descendant); end
  include Virtus::ConstMissingExtensions
  include Virtus::Extensions::Methods
end
module Virtus::InstanceMethods
  def [](name); end
  def []=(name, value); end
  def allowed_methods; end
  def assert_valid_name(name); end
  def freeze; end
  def reset_attribute(attribute_name); end
  def set_default_attributes!; end
  def set_default_attributes; end
end
module Virtus::InstanceMethods::Constructor
  def initialize(attributes = nil); end
end
module Virtus::InstanceMethods::MassAssignment
  def attributes; end
  def attributes=(attributes); end
  def to_h; end
  def to_hash; end
end
module Virtus::ValueObject
  def self.included(base); end
end
module Virtus::ValueObject::InstanceMethods
  def clone; end
  def dup; end
  def with(attribute_updates); end
end
module Virtus::ValueObject::AllowedWriterMethods
  def allowed_writer_methods; end
end
module Virtus::ValueObject::ClassMethods
  def attribute(name, type, options = nil); end
  def equalizer; end
end
class Virtus::Coercer
  def call(input); end
  def initialize(type); end
  def primitive; end
  def success?(primitive, input); end
  def type; end
end
class Virtus::AttributeSet < Module
  def <<(attribute); end
  def [](name); end
  def []=(name, attribute); end
  def coerce(attributes); end
  def define_reader_method(attribute, method_name, visibility); end
  def define_writer_method(attribute, method_name, visibility); end
  def each; end
  def finalize; end
  def get(object); end
  def initialize(parent = nil, attributes = nil); end
  def merge(attributes); end
  def merge_attributes(attributes); end
  def reset; end
  def self.create(descendant); end
  def set(object, attributes); end
  def set_defaults(object, filter = nil); end
  def skip_default?(object, attribute); end
  def update_index(name, attribute); end
  include Enumerable
end
class Virtus::Attribute
  def coerce(input); end
  def coercer; end
  def coercible?; end
  def default_value; end
  def define_accessor_methods(attribute_set); end
  def finalize; end
  def finalized?; end
  def initialize(type, options); end
  def lazy?; end
  def nullify_blank?; end
  def options; end
  def primitive; end
  def rename(name); end
  def required?; end
  def self.accessor(value = nil); end
  def self.build(type, options = nil); end
  def self.build_coercer(type, options = nil); end
  def self.build_type(definition); end
  def self.coerce(value = nil); end
  def self.default(value = nil); end
  def self.finalize(value = nil); end
  def self.lazy(value = nil); end
  def self.merge_options!(*arg0); end
  def self.nullify_blank(value = nil); end
  def self.primitive(value = nil); end
  def self.required(value = nil); end
  def self.strict(value = nil); end
  def strict?; end
  def type; end
  def value_coerced?(value); end
  extend DescendantsTracker
  include Anonymous_Equalizer_1
  include Equalizer::Methods
end
class Virtus::Attribute::DefaultValue
  def call(*arg0); end
  def initialize(value); end
  def self.build(*args); end
  def value; end
  extend DescendantsTracker
end
class Virtus::Attribute::DefaultValue::FromClonable < Virtus::Attribute::DefaultValue
  def call(*arg0); end
  def self.handle?(value); end
end
class Virtus::Attribute::DefaultValue::FromCallable < Virtus::Attribute::DefaultValue
  def call(*args); end
  def self.handle?(value); end
end
class Virtus::Attribute::DefaultValue::FromSymbol < Virtus::Attribute::DefaultValue
  def call(instance, _); end
  def self.handle?(value); end
end
module Anonymous_Equalizer_1
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Virtus::PendingAttribute
  def determine_type; end
  def finalize; end
  def finalized?; end
  def initialize(type, options); end
  def name; end
  def options; end
  def type; end
end
class Virtus::TypeDefinition
  def initialize(type); end
  def initialize_primitive; end
  def pending?; end
  def primitive; end
  def type; end
end
class Virtus::Attribute::Builder
  def attribute; end
  def determine_coercer; end
  def determine_visibility; end
  def initialize(type_definition, options); end
  def initialize_attribute; end
  def initialize_class; end
  def initialize_coercer; end
  def initialize_default_value; end
  def initialize_options(options); end
  def initialize_type; end
  def klass; end
  def options; end
  def self.call(type, options = nil); end
  def self.determine_type(klass, default = nil); end
  def type; end
  def type_definition; end
end
class Virtus::Attribute::Coercer < Virtus::Coercer
  def call(value); end
  def coercers; end
  def initialize(type, coercers); end
  def method; end
  def success?(primitive, value); end
end
module Virtus::Attribute::Accessor
  def defined?(instance); end
  def get(instance); end
  def instance_variable_name; end
  def name; end
  def public_reader?; end
  def public_writer?; end
  def self.extended(descendant); end
  def set(instance, value); end
  def set_default_value(instance); end
end
module Virtus::Attribute::Coercible
  def set(instance, value); end
end
module Virtus::Attribute::Strict
  def coerce(*arg0); end
end
module Virtus::Attribute::LazyDefault
  def get(instance); end
end
module Virtus::Attribute::NullifyBlank
  def coerce(input); end
end
class Virtus::Attribute::Boolean < Virtus::Attribute
  def define_accessor_methods(attribute_set); end
  def self.build_type(*arg0); end
  def value_coerced?(value); end
end
class Virtus::Attribute::Collection < Virtus::Attribute
  def coerce(value); end
  def finalize; end
  def finalized?; end
  def member_type; end
  def self.build_type(definition); end
  def self.merge_options!(type, options); end
end
class Virtus::Attribute::Collection::Type < Struct
  def coercion_method; end
  def member_type; end
  def member_type=(_); end
  def primitive; end
  def primitive=(_); end
  def self.[](*arg0); end
  def self.axiom_type?(type); end
  def self.infer(type, primitive); end
  def self.infer_member_type(type); end
  def self.members; end
  def self.new(*arg0); end
  def self.pending?(primitive); end
end
class Virtus::Attribute::Hash < Virtus::Attribute
  def coerce(*arg0); end
  def finalize; end
  def finalized?; end
  def key_type; end
  def self.build_type(definition); end
  def self.merge_options!(type, options); end
  def value_type; end
end
class Virtus::Attribute::Hash::Type < Struct
  def coercion_method; end
  def key_type; end
  def key_type=(_); end
  def primitive; end
  def self.[](*arg0); end
  def self.axiom_type?(type); end
  def self.determine_type(type); end
  def self.infer(type); end
  def self.infer_key_and_value_types(type); end
  def self.members; end
  def self.new(*arg0); end
  def self.pending?(primitive); end
  def value_type; end
  def value_type=(_); end
end
class Virtus::Attribute::EmbeddedValue < Virtus::Attribute
  def self.build_coercer(type, _options); end
  def self.build_type(definition); end
  def self.handles?(klass); end
end
class Virtus::Attribute::EmbeddedValue::FromStruct < Virtus::Coercer
  def call(input); end
end
class Virtus::Attribute::EmbeddedValue::FromOpenStruct < Virtus::Coercer
  def call(input); end
end
class Virtus::CoercionError < StandardError
  def attribute; end
  def attribute_name; end
  def attribute_name?; end
  def build_message; end
  def initialize(output, attribute); end
  def output; end
  def target_type; end
end
